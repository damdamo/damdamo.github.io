<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-08-12T12:42:49+00:00</updated><id>/feed.xml</id><title type="html">Damien Morard</title><subtitle>I share my passion about Computer Science and programming. You can find posts about my research, some tutorials in programming, or just sharing my knowledge. I particularly use the Swift language, created by Apple.</subtitle><author><name>Damien Morard</name></author><entry><title type="html">Les closures, l’application partielle et la curryfication (Partie 3/3) (Swift)</title><link href="/tutorial/2019/08/11/curryfication.html" rel="alternate" type="text/html" title="Les closures, l'application partielle et la curryfication (Partie 3/3) (Swift)" /><published>2019-08-11T00:00:00+00:00</published><updated>2019-08-11T00:00:00+00:00</updated><id>/tutorial/2019/08/11/curryfication</id><content type="html" xml:base="/tutorial/2019/08/11/curryfication.html">&lt;p&gt;Si vous n’avez pas encore lu les deux précédentes parties, vous pouvez les retrouver ci-dessous:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;../../../2019/08/09/closure-fr.html&quot;&gt;Partie 1: Les closures&lt;/a&gt; !&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;../../../2019/08/10/partial-application-fr.html&quot;&gt;Partie 2: L’application partielle et précision sur les closures&lt;/a&gt;
Il est important de bien comprendre les notions abordés dans nos deux précédents chapitres !&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;la-curryfication&quot;&gt;La curryfication&lt;/h2&gt;

&lt;p&gt;J’espère que vous êtes bien au clair avec les closures et l’application partielle vu que cette dernière partie va tout mettre à profit.&lt;/p&gt;

&lt;p&gt;La curryfication est le principe de prendre une fonction avec “&lt;em&gt;n&lt;/em&gt;” paramètres et de la transformer en “&lt;em&gt;n&lt;/em&gt;” fonctions avec chacune un argument.&lt;/p&gt;

&lt;p&gt;À l’inverse l’application partielle prend une fonction à “&lt;em&gt;n&lt;/em&gt;” arguments et la transforme en “&lt;em&gt;m&lt;/em&gt;” fonctions, avec “&lt;em&gt;m &amp;lt;= n&lt;/em&gt;” (Nous avons au plus autant de fonctions que d’arguments).
Prenez le temps de relire ces phrase plusieurs fois si besoin.&lt;/p&gt;

&lt;p&gt;Vous vous souvenez de l’exemple du poids de la dernière partie ?
Même si l’objectif n’était pas de curryfier notre fonction, c’est pourtant ce que nous avons fait.&lt;/p&gt;

&lt;p&gt;Si nous regardons juste en terme de signature de fonctions, voici un exemple:
&lt;code class=&quot;highlighter-rouge&quot;&gt;(Int, Int) -&amp;gt; Int&lt;/code&gt; devient &lt;code class=&quot;highlighter-rouge&quot;&gt;(Int) -&amp;gt; (Int) -&amp;gt; Int&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Nous pouvons faire encore plus:
&lt;code class=&quot;highlighter-rouge&quot;&gt;(Int, Int, Int) -&amp;gt; Int&lt;/code&gt; devient &lt;code class=&quot;highlighter-rouge&quot;&gt;(Int) -&amp;gt; (Int) -&amp;gt; (Int) -&amp;gt; Int&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;C’est bien joli mais je pense que vous voulez voir des exemples un peu plus concret.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Version classique&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Version curry&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addCurry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addCurry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;La version classique est plus intuitive à réaliser de prime abord.
La version “&lt;em&gt;addCurry&lt;/em&gt;” reprend exactement toutes les notions abordées jusqu’à présent.
Nous avons simplement décomposé le second argument de la fonction dans notre closure.&lt;/p&gt;

&lt;p&gt;Je vous montre aussi l’exemple à trois arguments tant que nous y sommes !&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addCurry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nous prenons simplement chaque argument de la fonction “&lt;em&gt;add&lt;/em&gt;” pour faire en sorte d’avoir des fonctions avec un unique argument.&lt;/p&gt;

&lt;p&gt;Le principe de curryfication peut s’appliquer dans les deux sens, nous pouvons prendre une fonction pour la curryfier ou la decurryfier.&lt;/p&gt;

&lt;h3 id=&quot;différence-entre-application-partielle-et-curryfication&quot;&gt;Différence entre application partielle et curryfication&lt;/h3&gt;

&lt;p&gt;Au final, nous pourrions croire que la curryfication est un cas particulier de l’application partielle mais il existe une différence qui sépare ces deux notions.
L’application partielle n’a pas nécessité à avoir un type de retour, tandis que la curryfication retournera toujours une fonction à un argument jusqu’au dernier type de retour qui sera la valeur.
Cette nuance est subtile mais à le mérite d’exister, mais nous ne sommes pas ici pour débattre plus en détail sur ce sujet.&lt;/p&gt;

&lt;h3 id=&quot;avantage-de-la-curryfication&quot;&gt;Avantage de la curryfication&lt;/h3&gt;

&lt;p&gt;Quand vous curryfier une fonction, vous la transformez en ce que nous appelons une fonction “&lt;strong&gt;pure&lt;/strong&gt;”, possédant une propriété très intéressante.
En effet les fonctions pures n’ont aucun effet de bord, c’est-à-dire qu’aucun comportement (mutation) non désirable dans le programme n’est possible.&lt;/p&gt;

&lt;p&gt;Vous avez les mêmes avantages qu’avec l’application partielle:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Une meilleure décomposition du code&lt;/li&gt;
  &lt;li&gt;Plus de clarté et de lisibilité du code&lt;/li&gt;
  &lt;li&gt;La possibilité de déclarer des variables à différents niveaux de l’exécution.&lt;/li&gt;
  &lt;li&gt;Vous pouvez plus facilement cibler à quel niveau vous désirez appliquer une modification.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Je vous conseille vivement de tester par vous-même, c’est le meilleur moyen de vous en rendre compte.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Nous arrivons à la fin de notre série de tutoriel sur les closures, l’application partielle et la curryfication.
J’espère avoir démystifier ces principes, et surtout vous avoir apporté une meilleure compréhension globale sur le sujet.&lt;/p&gt;

&lt;p&gt;Je n’ai pas couvert tous les cas, et certains sujets méritent encore d’être explorés plus en profondeur.
J’aurai l’occasion de revenir dans un article sur l’utilisation des closures dans les fonctions “&lt;em&gt;map&lt;/em&gt;”, “&lt;em&gt;filter&lt;/em&gt;” et “&lt;em&gt;reduce&lt;/em&gt;”.&lt;/p&gt;

&lt;p&gt;Si vous avez des remarques / suggestions n’hésitez pas, je tâcherai de les prendre en compte au mieux.&lt;/p&gt;

&lt;p&gt;Merci de m’avoir lu et j’espère vous retrouver dans d’autres articles !&lt;/p&gt;</content><author><name>Damien</name></author><category term="[&quot;tutorial&quot;]" /><summary type="html">Si vous n’avez pas encore lu les deux précédentes parties, vous pouvez les retrouver ci-dessous: Partie 1: Les closures ! Partie 2: L’application partielle et précision sur les closures Il est important de bien comprendre les notions abordés dans nos deux précédents chapitres !</summary></entry><entry><title type="html">Introduction</title><link href="/personal/2019/08/10/first.html" rel="alternate" type="text/html" title="Introduction" /><published>2019-08-10T00:00:00+00:00</published><updated>2019-08-10T00:00:00+00:00</updated><id>/personal/2019/08/10/first</id><content type="html" xml:base="/personal/2019/08/10/first.html">&lt;p&gt;Hello !
I’m Damien and I decided to create my own website.
Why ? Because I just want to share my passion about Computer Science !
I can share you my research, different kind of tutorial to enhance your (and my) knowledge on a particular subject, or just my opinion.&lt;/p&gt;

&lt;p&gt;Here some social network where you can find me:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.linkedin.com/in/damienmorard/&quot;&gt;Linkedin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/damdamo&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Damien</name></author><category term="[&quot;personal&quot;]" /><summary type="html">Hello ! I’m Damien and I decided to create my own website. Why ? Because I just want to share my passion about Computer Science ! I can share you my research, different kind of tutorial to enhance your (and my) knowledge on a particular subject, or just my opinion.</summary></entry><entry><title type="html">Les closures, l’application partielle et la curryfication (Partie 2/3) (Swift)</title><link href="/tutorial/2019/08/10/partial-application-fr.html" rel="alternate" type="text/html" title="Les closures, l'application partielle et la curryfication (Partie 2/3) (Swift)" /><published>2019-08-10T00:00:00+00:00</published><updated>2019-08-10T00:00:00+00:00</updated><id>/tutorial/2019/08/10/partial-application-fr</id><content type="html" xml:base="/tutorial/2019/08/10/partial-application-fr.html">&lt;p&gt;Si vous n’avez pas encore lu la première partie, c’est &lt;a href=&quot;../../../2019/08/09/closure-fr.html&quot;&gt;ici&lt;/a&gt; !
Il est important de bien comprendre les notations utilisées lors de la précédente partie.&lt;/p&gt;

&lt;h2 id=&quot;lapplication-partielle&quot;&gt;L’application partielle&lt;/h2&gt;

&lt;p&gt;J’espère déjà que la boîte noire que représente les closures pour certains ne vous concerne plus.
Vous vous doutez bien que si nous avons vu les closures, ce n’est pas pour tout oublier et changer complètement de registre !&lt;/p&gt;

&lt;p&gt;L’application &lt;strong&gt;partielle&lt;/strong&gt; a pour principe d’initialiser des variables en fonction d’où nous nous situons dans l’appel d’une fonction/closure.
Imaginons que vous fassiez des pizzas (de A à Z).
En premier lieu vous allez faire la pâte, et seulement ensuite vous mettrez les ingrédients.
Vous êtes d’accord que la même pâte est utilisé peu importe les ingrédients que vous mettez (Les Italiens me pardonneront) ?
C’est un peu la même chose pour nous, parfois nous allons avoir des ingrédients qui seront toujours présent peu importe ce que nous faisons par la suite.&lt;/p&gt;

&lt;h3 id=&quot;lexemple-du-poids&quot;&gt;L’exemple du poids&lt;/h3&gt;

&lt;p&gt;Prenons un exemple plus concret !
Vous souvenez vous de vos cours de physique ?
Ne vous inquiétez pas, nous n’allons rien voir de bien compliqué.
Vous savez sûrement que la gravité n’est pas la même sur la Terre que sur la Lune.
Nous avons la formule suivante en physique :&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;P = m * g&lt;/code&gt; (&lt;em&gt;P&lt;/em&gt; étant le poids, &lt;em&gt;m&lt;/em&gt; la masse et &lt;em&gt;g&lt;/em&gt; la gravité).
La masse et le poids sont deux choses distinctes !&lt;/p&gt;

&lt;p&gt;La gravité de la Terre est de 9.81 N/kg, et supposons une masse de 70 kg.
Nous obtenons alors &lt;em&gt;P = 9.81&lt;/em&gt; * &lt;em&gt;70&lt;/em&gt; (N), qui est le poids sur Terre d’une personne avec une masse particulière.
Après cette légère paranthèse, vous allez comprendre pourquoi je vous ai introduit ces quelques notions.&lt;/p&gt;

&lt;p&gt;Je veux désormais créer une fonction permettant de calculer le poids d’une personne sur Terre.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poidsTerre&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;9.81&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;poidsTerre&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Si maintenant j’aimerai avoir le poids d’une personne sur la Lune, comment suis-je censé faire ?
Je dois écrire une nouvelle fonction pour changer une seule valeur ?&lt;/p&gt;

&lt;p&gt;Heureusement, il y a un moyen plus générique de le faire pour ne pas avoir à écrire une nouvelle fonction à chaque fois que nous voulons connaître notre poids sur une planète différente !&lt;/p&gt;

&lt;p&gt;Je vous propose le code ci-dessous faisant appel à l’application partielle:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Wooooooow, c’est peut-être ce que vous êtes entrain de vous dire.
Je vous l’accorde, il y a pas mal de différences entre les deux versions, mais nous allons décortiquer tout cela ensemble.
La première principale différence est la signature de la fonction.
En effet, nous ne retournons pas directement un “&lt;em&gt;Double&lt;/em&gt;”, mais une fonction qui prend un “&lt;em&gt;Double&lt;/em&gt;” et retourne un “&lt;em&gt;Double&lt;/em&gt;”.
C’est ce que signifie le retour “&lt;em&gt;(Double) -&amp;gt; Double&lt;/em&gt;”.
Cette syntaxe vous rappelle sûrement ce que nous avons vu avec les opérations de la partie précédente.&lt;/p&gt;

&lt;p&gt;Il nous faut donc retourner une fonction, c’est pour cette raison que nous avons créé “&lt;em&gt;foo&lt;/em&gt;”, qui a la signature “&lt;em&gt;(Double) -&amp;gt; Double&lt;/em&gt;” (exactement ce que nous voulons).
Cette seconde fonction fait juste l’application de la formule vu plus haut.
Nous prenons bien soin de remarquer que nous retournons “&lt;em&gt;foo&lt;/em&gt;” et non “&lt;em&gt;foo(…)&lt;/em&gt;”.
Ce n’est absolument pas la même chose, d’un côté nous retournons la fonction, et de l’autre nous retournons l’appel à cette fonction !&lt;/p&gt;

&lt;p&gt;La signature de “&lt;em&gt;foo&lt;/em&gt;” est “&lt;em&gt;(Double) -&amp;gt; Double&lt;/em&gt;” tandis que celle de l’appel de “&lt;em&gt;foo(…)&lt;/em&gt;” est “&lt;em&gt;Double&lt;/em&gt;”.
Surtout que pour appeler la fonction &lt;em&gt;foo(…)&lt;/em&gt; il nous faudrait un paramètre que nous n’avons pas encore.
Vous voulez vous en convaincre ?
À ce moment tenter d’afficher le résultat de l’appel de “&lt;em&gt;poids&lt;/em&gt;” avec “&lt;em&gt;g&lt;/em&gt;”.
Réfléchissez deux minutes avant de passer à la suite.&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;Allez on regarde !&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Retourne (Function)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;poidsTerre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;9.81&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;poidsTerre&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Retourne (Double) -&amp;gt; Double&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;poidsTerre&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Swift nous dit que le résultat est une fonction, dont vous connaissez la signature !
Si nous désirons connaître le résultat pour une masse particulière, il nous faut appeler cette nouvelle fonction avec le paramètre de “&lt;em&gt;foo&lt;/em&gt;”.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Possibilité 1&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;poids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;9.81&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Possibilité 2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;poidsTerre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;9.81&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;poidsTerre&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tout l’intérêt réside dans la possibilité 2, nous pouvons initialiser une variable avec une gravité particulière.
Nous nous en servons ensuite comme d’une nouvelle fonction qui attend en paramètre la masse.
C’est quand même plus pratique d’avoir à déclarer une seule fonction, que vous pouvez aisément mettre dans une variable.&lt;/p&gt;

&lt;p&gt;Je viens de vous montrer le fonctionnement général, cependant il vous faudra pratiquer ces notions pour que cela devienne intuitif.&lt;/p&gt;

&lt;h3 id=&quot;une-définition-plus-complète-de-la-closure&quot;&gt;Une définition plus complète de la closure&lt;/h3&gt;

&lt;p&gt;Avez-vous remarqué le lien avec les closures ?
Depuis le début nous nous en servons, les closures sont partout !
Quand nous déclarons “&lt;em&gt;poidsTerre&lt;/em&gt;”, nous gardons en mémoire une closure.
Le concept que nous avons vu jusqu’à maintenant restait simple, sans aborder vraiment sa consistance même !&lt;/p&gt;

&lt;p&gt;Au final, une closure ce n’est rien d’autre qu’une fonction accompagnée de son environnement lexical.
Un environnement lexical ? What is it ?
C’est simplement toutes les valeurs qui ont été capturées et qui peuvent être utilisées dans l’appel de notre fonction.
Prenons l’exemple de “&lt;em&gt;poidsTerre&lt;/em&gt;” pour mieux comprendre.
Dans notre cas, “&lt;em&gt;poidsTerre&lt;/em&gt;” est une closure contenant comme valeur capturé “&lt;em&gt;g&lt;/em&gt;” étant égal à &lt;em&gt;9.81&lt;/em&gt;, et une fonction foo.
Dire que nous avons capturé “&lt;em&gt;g&lt;/em&gt;” revient à dire que notre variable sera connue dans l’appel de “&lt;em&gt;foo&lt;/em&gt;”.
Cette notion est très large et fait partie de ce que nous appelons la &lt;a href=&quot;https://fr.wikipedia.org/wiki/Port%C3%A9e_(informatique)&quot;&gt;portée&lt;/a&gt; (scope).
Nous ne nous étendrons pas sur ce sujet dans cet article, mais si vous désirez en savoir plus sur le fonctionnement je vous y encourage vivement !&lt;/p&gt;

&lt;p&gt;Vous avez peut-être remarqué le nom de fonction “&lt;em&gt;foo&lt;/em&gt;” qui n’a pas vraiment de signification.
Ce nom sera inconnu en dehors du corps de la fonction “&lt;em&gt;poids&lt;/em&gt;”, et vous ne vous en servirez quasiment jamais (parce qu’il ne faut jamais dire jamais) !
Au moment de l’appelée avec “&lt;em&gt;poidsTerre&lt;/em&gt;”, pas besoin de donner un nom de fonction, et pas non plus besoin de donner le nom du label.&lt;/p&gt;

&lt;p&gt;Alors ce serait pas mieux de retourner directement une closure plutôt qu’une fonction dont le nom ne nous intéresse guère ?
Bien vu !&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;poids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Vous pouvez essayer de votre côté, nous avons exactement le même résultat attendu.
Nous avons repris la syntaxe des closures que nous avons vu dans la partie précédente.
C’est comme retournée une fonction sans nom, et ça tombe bien vu que nous n’en avons pas besoin !&lt;/p&gt;

&lt;p&gt;L’application partielle permet de donner autant de paramètres que souhaités, de même que nous pouvons faire une cascade de closure qui demanderont chacunes divers paramètres.&lt;/p&gt;

&lt;p&gt;Nous sommes enfin parés pour attaquer la dernière partie avec la curryfication !&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../../2019/08/11/curryfication.html&quot;&gt;Partie 3: La curryfication&lt;/a&gt;&lt;/p&gt;</content><author><name>Damien</name></author><category term="[&quot;tutorial&quot;]" /><summary type="html">Si vous n’avez pas encore lu la première partie, c’est ici ! Il est important de bien comprendre les notations utilisées lors de la précédente partie.</summary></entry><entry><title type="html">Les closures, l’application partielle et la curryfication (Partie 1/3) (Swift)</title><link href="/tutorial/2019/08/09/closure-fr.html" rel="alternate" type="text/html" title="Les closures, l'application partielle et la curryfication (Partie 1/3) (Swift)" /><published>2019-08-09T00:00:00+00:00</published><updated>2019-08-09T00:00:00+00:00</updated><id>/tutorial/2019/08/09/closure-fr</id><content type="html" xml:base="/tutorial/2019/08/09/closure-fr.html">&lt;p&gt;Disponible sur &lt;a href=&quot;https://medium.com/@dmorard1/fermeture-closure-application-partielle-et-curryfication-en-swift-partie-1-3-4c2c6f2bce67&quot;&gt;Medium&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Ce titre vous fait peur ? Ou plutôt les notions abordées sont effrayantes ?
Ne fuyez pas et prenez le temps à mes côtés de démystifier ses concepts, comprendre le fonctionnement derrière ce qui peut vous sembler être de la magie.&lt;/p&gt;

&lt;h2 id=&quot;bienvenue-dans-le-monde-fantastique-des-closures-ou-fermetures&quot;&gt;Bienvenue dans le monde fantastique des closures (ou fermetures)&lt;/h2&gt;

&lt;p&gt;Qu’est-ce que nous dit la documentation &lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/Closures.html&quot;&gt;Swift&lt;/a&gt; à ce sujet ?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Closures are self-contained blocks of functionality that can be passed around and used in your code.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Les closures sont des blocs autonomes composés de fonctionnalités pouvant être passées et utilisées dans votre code”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Finalement, c’est pas un peu comme une boîte à outils ? Dans cette boîte nous pouvons imaginer avoir des outils, et les manipuler nous permet d’obtenir/modifier certaines pièces.
Cette définition reste un peu générale, mais la documentation ne s’arrête pas là:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Closures can capture and store references to any constants and variables from the context in which they are defined.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Les closures peuvent capturer et enregistrer des références pour n’importe quelles constantes ou variables du contexte dans laquelles elles sont définies.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Je pense que nous avons besoin de clarifier certaines notions de ces définitions pour bien comprendre la théorie.
Une closure c’est un peu comme un environnement, une mémoire qui va garder des valeurs que nous avons défini à l’intérieur.
C’est comme quand vous déclarez des variables, sauf qu’elles seront seulement accessible dans une certaine portée.
Je crois qu’un petit exemple ne fera pas de mal:&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Use of unresolved identifier 'x'&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dans ce petit exemple, nous avons une fonction “&lt;em&gt;foo&lt;/em&gt;” qui déclare à l’intérieur une variable “&lt;em&gt;x&lt;/em&gt;”.
Cette variable est visible seulement à l’intérieur de notre fonction, une fois sortie celle-ci n’existe plus.
C’est la même chose pour une closure !
Nous avons donc des variables, et des fonctionnalités qui ne sont rien d’autre que des fonctions.&lt;/p&gt;

&lt;p&gt;Nous aurons l’occasion un peu plus tard de revenir en détail sur les closures.
Pour l’heure, regardons comment nous pouvons les manipuler en Swift.&lt;/p&gt;

&lt;p&gt;Qu’est-ce que Swift nous dit-il par rapport à la représentation syntaxique des closures ?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Closure expression syntax has the following general form:”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;statements&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cette syntaxe vous a l’air peut-être rude, et c’est sûrement le premier point qui fait défaut quand nous désirons manipuler des closures.
Il faut avant tout comprendre la syntaxe pour l’utiliser convenablement.&lt;/p&gt;

&lt;p&gt;Prenons un petit exemple en utilisant ce que nous venons de voir.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Retourne 42&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;clos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nous pouvons voir une closure comme une fonction sans nom, qui est appelée grâce à la variable à laquelle elle a été liée (clos dans notre cas).
Comme une fonction nous avons des paramètres d’entrée, le type de ces paramètres et le type de sortie.
Plutôt que d’avoir la syntaxe des accolades pour séparer la signature et le corps de la fonction, nous avons le mot-clé “&lt;em&gt;in&lt;/em&gt; “.
Nous avons pour terminer la valeur de retour que nous signalons aussi avec le mot-clé “&lt;em&gt;return&lt;/em&gt; “.
L’appel de cette closure se fait exactement de la même manière que si le nom de notre fonction était &lt;em&gt;clos&lt;/em&gt;.
C’est-à-dire qu’il nous suffit de passer à notre closure les paramètres attendus.
Vous aurez compris que notre closure fait simplement l’addition de nos deux paramètres, rien de très passionnant n’est-ce pas ?&lt;/p&gt;

&lt;p&gt;Passons un cran au-dessus en supposant que nous avons cette fois une fonction prenant en paramètre une closure !&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nous avons désormais la fonction &lt;em&gt;apply&lt;/em&gt;, qui prend deux entiers et va appliquer une opération sur ceux-ci.
Il faut être au clair sur la notation “&lt;em&gt;op: (Int, Int) -&amp;gt; Int&lt;/em&gt; “.
Cela signifie que le paramètre &lt;em&gt;op&lt;/em&gt; attend une fonction ou une closure qui prend deux entiers comme paramètres d’entrée, et retourne un entier.
Vous l’avez peut-être remarqué, mais la closure que nous avons écrite avant répond parfaitement à ces conditions.
Nous pouvons donc simplement appelée notre fonction ainsi :&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Retourne 42&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Vous commencez à comprendre ?
Nous pouvons même faire plus simple sans avoir à déclarer notre closure au préalable comme ceci :&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Toutes les fonctions/closures ayant pour signature “&lt;em&gt;(Int, Int) -&amp;gt; Int&lt;/em&gt; “ peuvent être utilisées comme paramètre de &lt;em&gt;op&lt;/em&gt;, peu importe que celles-ci aient été déclarées avant ou directement à l’appel.&lt;/p&gt;

&lt;p&gt;Vous voulez quelques petites astuces syntaxiques pour vous simplifier la vie ?
C’est parti !&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Vous avez peut-être remarqué mais nous avons omis le type de nos paramètres, et même le type de sortie ! Pourquoi ça fonctionne alors ?
Dites merci à l’&lt;a href=&quot;https://fr.wikipedia.org/wiki/Inf%C3%A9rence_de_types&quot;&gt;inférence de type&lt;/a&gt; et non à une magie obscure.
Au moment de déclarer la fonction &lt;em&gt;apply&lt;/em&gt;, nous avons déjà dit à Swift les types que nous attendions.
Swift a automatiquement fait le rapprochement entre ce qu’il attend comme type et ce que vous lui donnez. C’est franchement génial non ?
Pourtant nous sommes loin d’avoir vu toutes les simplifications possibles.
Next !&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pas besoin de return ? Quand il n’y a aucune ambiguïté pour un cas aussi simple, Swift comprend que “&lt;em&gt;x+y&lt;/em&gt; “ est la valeur de retour. Bien entendu, vous pouvez mettre autant de code que vous désirez après le “&lt;em&gt;in&lt;/em&gt; “, cependant il faudra remettre un “&lt;em&gt;return&lt;/em&gt; “ !&lt;/p&gt;

&lt;p&gt;C’est pas encore fini, nous pouvons encore faire mieux !&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;J’ai été trop loin ? Testez et vous verrez que ça marche !
Dans ce code, nous n’avons même pas eu besoin de faire une quelconque différence entre signature et corps de fonction.
Par le même principe que l’inférence de type, dans cette situation Swift sait ce qu’il attend.
Comment récupérons-nous les valeurs de nos paramètres ?
“&lt;em&gt;$0&lt;/em&gt; “ et “&lt;em&gt;$1&lt;/em&gt; “ sont des noms conventionnels que Swift utilise par défaut, prenant les valeurs des paramètres d’entrée.&lt;/p&gt;

&lt;p&gt;Un peu perdu ? Reprenons la signature de “&lt;em&gt;op: (Int, Int) -&amp;gt; Int&lt;/em&gt; “.
Donc “&lt;em&gt;$0&lt;/em&gt; “ correspond au premier entier et “&lt;em&gt;$1&lt;/em&gt; “ au second.
L’ordre est important, car si nous avions par exemple “&lt;em&gt;op: (Int, String) -&amp;gt; Int&lt;/em&gt; “, “&lt;em&gt;$1&lt;/em&gt; “ serait alors une chaîne de caractères.
Swift a donc lié à des noms prédéfinis les valeurs, plutôt que nous donnions nous-mêmes le nom de celle-ci.
Pour le “&lt;em&gt;return&lt;/em&gt; “ qui n’est pas nécessaire je vous renvoie à ce que j’ai dit plus haut.&lt;/p&gt;

&lt;p&gt;Encore un petit truc pour la route purement syntaxique, mais qui vous facilitera sûrement la vie !&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Quand le dernier paramètre de votre fonction est une closure, vous pouvez l’appeler de cette manière.
Même pas besoin de donner le nom du paramètre, vous écrivez juste entre accolade votre closure.
Toutes les closures vues précédemment fonctionnent avec cette syntaxe.&lt;/p&gt;

&lt;p&gt;Quand nous manipulons des fonctions aussi simple, vous conviendrez que nous pouvons nous simplifier la vie.
Il faut cependant toujours faire attention à la lisibilité.&lt;/p&gt;

&lt;p&gt;Nous en avons terminé avec cette première partie sur les closures, passons sans plus tarder
à l’application partielle !&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../../2019/08/10/partial-application-fr.html&quot;&gt;Partie 2: L’application partielle&lt;/a&gt;&lt;/p&gt;</content><author><name>Damien</name></author><category term="[&quot;tutorial&quot;]" /><summary type="html">Disponible sur Medium.</summary></entry></feed>